{"version":3,"file":"Popup.js","sourceRoot":"","sources":["../../../src/Libraries/Components/Popup/Popup.tsx"],"names":[],"mappings":"AAAA;;;;GAIG;AACH,YAAY,CAAC;;;;;;AAEb,kDAA0B;AAC1B,+CAAgF;AAGhF,MAAM,MAAM,GAAG,yBAAU,CAAC,MAAM,CAAC;IAC/B,QAAQ,EAAE;QACR,QAAQ,EAAE,UAAU;KACrB;CACF,CAAC,CAAC;AAOH,MAAM,QAAQ,GAAG,IAAA,qCAAsB,EAAc,UAAU,CAAC,CAAC;AAEjE;;;;;;;GAOG;AACH,MAAa,KAAM,SAAQ,eAAK,CAAC,SAAyC;IACjE,MAAM,CAAC,wBAAwB,CACpC,SAAsB,EACtB,SAA4B;QAE5B,mGAAmG;QACnG,IAAI,SAAS,CAAC,SAAS,KAAK,SAAS,CAAC,MAAM,EAAE;YAC5C,qEAAqE;YACrE,MAAM,SAAS,GAAkB,IAAA,6BAAc,EAC7C,SAAS,CAAC,MAIqB,CAChC,CAAC;YAEF,OAAO;gBACL,MAAM,EAAE,SAAS;gBACjB,SAAS,EAAE,SAAS,CAAC,MAAM;aAC5B,CAAC;SACH;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,YAAY,KAAkB;QAC5B,KAAK,CAAC,KAAK,CAAC,CAAC;QACb,IAAI,CAAC,KAAK,GAAG,EAAC,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC;IACpD,CAAC;IAEM,MAAM;QACX,MAAM,KAAK,GAAG,EAAC,GAAG,IAAI,CAAC,KAAK,EAAC,CAAC;QAC9B,KAAK,CAAC,KAAK,GAAG,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QAElD,OAAO,8BAAC,QAAQ,OAAK,KAAK,EAAE,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,GAAI,CAAC;IAC5D,CAAC;CACF;AApCD,sBAoCC","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n * @format\n */\n'use strict';\n\nimport React from 'react';\nimport {findNodeHandle, requireNativeComponent, StyleSheet} from 'react-native';\nimport {IPopupProps} from './PopupProps';\n\nconst styles = StyleSheet.create({\n  rctPopup: {\n    position: 'absolute',\n  },\n});\n\nexport interface IPopupTargetState {\n  target?: number | null;\n  targetRef?: React.ReactNode;\n}\n\nconst RCTPopup = requireNativeComponent<IPopupProps>('RCTPopup');\n\n/**\n * Renders a popup component.\n *\n * This is a controlled component that requires an `onDismiss` callback that\n * updates the `isOpen` prop in order for the component to reflect user actions.\n *\n * @keyword popup\n */\nexport class Popup extends React.Component<IPopupProps, IPopupTargetState> {\n  public static getDerivedStateFromProps(\n    nextProps: IPopupProps,\n    prevState: IPopupTargetState,\n  ): IPopupTargetState {\n    // Check if we're given a new target property; we need to resolve it to a node handle before render\n    if (prevState.targetRef !== nextProps.target) {\n      // Map the 'target' property to a node tag to use in the native layer\n      const newTarget: number | null = findNodeHandle(\n        nextProps.target as\n          | null\n          | number\n          | React.Component<IPopupProps, IPopupTargetState>\n          | React.ComponentClass<Popup>,\n      );\n\n      return {\n        target: newTarget,\n        targetRef: nextProps.target,\n      };\n    }\n\n    return prevState;\n  }\n\n  constructor(props: IPopupProps) {\n    super(props);\n    this.state = {target: undefined, targetRef: null};\n  }\n\n  public render(): JSX.Element {\n    const props = {...this.props};\n    props.style = [styles.rctPopup, this.props.style];\n\n    return <RCTPopup {...props} target={this.state.target} />;\n  }\n}\n"]}