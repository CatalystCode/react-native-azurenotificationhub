{"version":3,"file":"Flyout.js","sourceRoot":"","sources":["../../../src/Libraries/Components/Flyout/Flyout.tsx"],"names":[],"mappings":"AAAA;;;;GAIG;AACH,YAAY,CAAC;;;;;;AAEb,kDAA0B;AAC1B,+CAAgF;AAGhF,MAAM,MAAM,GAAG,yBAAU,CAAC,MAAM,CAAC;IAC/B,SAAS,EAAE;QACT,QAAQ,EAAE,UAAU;KACrB;CACF,CAAC,CAAC;AAOH,MAAM,SAAS,GAAG,IAAA,qCAAsB,EAAe,WAAW,CAAC,CAAC;AAEpE;;;;;;;GAOG;AACH,MAAa,MAAO,SAAQ,eAAK,CAAC,SAA2C;IACpE,MAAM,CAAC,wBAAwB,CACpC,SAAuB,EACvB,SAA6B;QAE7B,mGAAmG;QACnG,IAAI,SAAS,CAAC,SAAS,KAAK,SAAS,CAAC,MAAM,EAAE;YAC5C,qEAAqE;YACrE,MAAM,SAAS,GAAkB,IAAA,6BAAc,EAC7C,SAAS,CAAC,MAIsB,CACjC,CAAC;YAEF,OAAO;gBACL,MAAM,EAAE,SAAS;gBACjB,SAAS,EAAE,SAAS,CAAC,MAAM;aAC5B,CAAC;SACH;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,YAAY,KAAmB;QAC7B,KAAK,CAAC,KAAK,CAAC,CAAC;QACb,IAAI,CAAC,KAAK,GAAG,EAAC,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC;IACpD,CAAC;IAEM,MAAM;QACX,MAAM,KAAK,GAAG,EAAC,GAAG,IAAI,CAAC,KAAK,EAAC,CAAC;QAE9B,OAAO,CACL,8BAAC,SAAS,OACJ,KAAK,EACT,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,EACzB,KAAK,EAAE,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAC3C,CACH,CAAC;IACJ,CAAC;CACF;AAzCD,wBAyCC","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n * @format\n */\n'use strict';\n\nimport React from 'react';\nimport {findNodeHandle, requireNativeComponent, StyleSheet} from 'react-native';\nimport {IFlyoutProps} from './FlyoutProps';\n\nconst styles = StyleSheet.create({\n  rctFlyout: {\n    position: 'absolute',\n  },\n});\n\nexport interface IFlyoutTargetState {\n  target?: number | null;\n  targetRef?: React.ReactNode;\n}\n\nconst RCTFlyout = requireNativeComponent<IFlyoutProps>('RCTFlyout');\n\n/**\n * Renders a flyout component.\n *\n * This is a controlled component that requires an `onDismiss` callback that\n * updates the `isOpen` prop in order for the component to reflect user actions.\n *\n * @keyword flyout\n */\nexport class Flyout extends React.Component<IFlyoutProps, IFlyoutTargetState> {\n  public static getDerivedStateFromProps(\n    nextProps: IFlyoutProps,\n    prevState: IFlyoutTargetState,\n  ): IFlyoutTargetState {\n    // Check if we're given a new target property; we need to resolve it to a node handle before render\n    if (prevState.targetRef !== nextProps.target) {\n      // Map the 'target' property to a node tag to use in the native layer\n      const newtarget: number | null = findNodeHandle(\n        nextProps.target as\n          | null\n          | number\n          | React.Component<IFlyoutProps, IFlyoutTargetState>\n          | React.ComponentClass<Flyout>,\n      );\n\n      return {\n        target: newtarget,\n        targetRef: nextProps.target,\n      };\n    }\n\n    return prevState;\n  }\n\n  constructor(props: IFlyoutProps) {\n    super(props);\n    this.state = {target: undefined, targetRef: null};\n  }\n\n  public render(): JSX.Element {\n    const props = {...this.props};\n\n    return (\n      <RCTFlyout\n        {...props}\n        target={this.state.target}\n        style={[styles.rctFlyout, this.props.style]}\n      />\n    );\n  }\n}\n"]}