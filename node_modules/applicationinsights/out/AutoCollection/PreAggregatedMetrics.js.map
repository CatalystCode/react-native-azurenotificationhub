{"version":3,"file":"PreAggregatedMetrics.js","sourceRoot":"","sources":["../../AutoCollection/PreAggregatedMetrics.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,qDAAwD;AAGxD,6FAA2F;AAC3F,iGAQ4D;AAI5D;IAcI;;;OAGG;IACH,yCAAY,MAAuB,EAAE,kBAA0B;QAA1B,mCAAA,EAAA,0BAA0B;QAC3D,IAAI,CAAC,+BAA+B,CAAC,QAAQ,EAAE;YAC3C,+BAA+B,CAAC,QAAQ,GAAG,IAAI,CAAC;SACnD;QAED,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;QAC5B,+BAA+B,CAAC,6BAA6B,GAAG,EAAE,CAAC;QACnE,+BAA+B,CAAC,0BAA0B,GAAG,EAAE,CAAC;QAChE,+BAA+B,CAAC,4BAA4B,GAAG,EAAE,CAAC;QAClE,+BAA+B,CAAC,wBAAwB,GAAG,EAAE,CAAC;QAC9D,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,mBAAmB,GAAG,kBAAkB,CAAC;IAClD,CAAC;IAEM,gDAAM,GAAb,UAAc,SAAkB,EAAE,kBAA2B;QAA7D,iBAkBC;QAjBG,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,IAAI,CAAC,UAAU,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;YACzC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;SAC9B;QAED,IAAI,SAAS,EAAE;YACX,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBACf,IAAI,CAAC,mBAAmB,GAAG,kBAAkB,IAAI,IAAI,CAAC,mBAAmB,CAAC;gBAC1E,IAAI,CAAC,OAAO,GAAG,WAAW,CAAC,cAAM,OAAA,KAAI,CAAC,yBAAyB,EAAE,EAAhC,CAAgC,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC;gBAC7F,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC,8DAA8D;aACvF;SACJ;aAAM;YACH,IAAI,IAAI,CAAC,OAAO,EAAE;gBACd,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC5B,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;aAC5B;SACJ;IACL,CAAC;IAEa,8CAAc,GAA5B,UAA6B,UAAqC;QAC9D,IAAI,CAAC,+BAA+B,CAAC,SAAS,EAAE,EAAE;YAC9C,OAAO;SACV;QACD,IAAI,OAAO,GAA4B,+BAA+B,CAAC,qBAAqB,CAAC,UAAU,EAAE,IAAI,CAAC,4BAA4B,CAAC,CAAC;QAC5I,OAAO,CAAC,UAAU,EAAE,CAAC;IACzB,CAAC;IAEa,0CAAU,GAAxB,UAAyB,UAAiC;QACtD,IAAI,CAAC,+BAA+B,CAAC,SAAS,EAAE,EAAE;YAC9C,OAAO;SACV;QACD,IAAI,OAAO,GAA4B,+BAA+B,CAAC,qBAAqB,CAAC,UAAU,EAAE,IAAI,CAAC,wBAAwB,CAAC,CAAC;QACxI,OAAO,CAAC,UAAU,EAAE,CAAC;IACzB,CAAC;IAEa,4CAAY,GAA1B,UAA2B,QAAyB,EAAE,UAAmC;QACrF,IAAI,CAAC,+BAA+B,CAAC,SAAS,EAAE,EAAE;YAC9C,OAAO;SACV;QACD,IAAI,UAAkB,CAAC;QACvB,IAAI,OAAO,GAA4B,+BAA+B,CAAC,qBAAqB,CAAC,UAAU,EAAE,IAAI,CAAC,0BAA0B,CAAC,CAAC;QAC1I,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;YAC9B,uEAAuE;YACvE,UAAU,GAAG,CAAC,IAAI,IAAI,CAAC,aAAa,GAAG,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,0CAA0C;SACrG;aAAM,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;YACrC,UAAU,GAAG,QAAQ,CAAC;SACzB;aAAM;YACH,OAAO;SACV;QACD,OAAO,CAAC,qBAAqB,IAAI,UAAU,CAAC;QAC5C,OAAO,CAAC,UAAU,EAAE,CAAC;IACzB,CAAC;IAEa,+CAAe,GAA7B,UAA8B,QAAyB,EAAE,UAAsC;QAC3F,IAAI,CAAC,+BAA+B,CAAC,SAAS,EAAE,EAAE;YAC9C,OAAO;SACV;QACD,IAAI,OAAO,GAA4B,+BAA+B,CAAC,qBAAqB,CAAC,UAAU,EAAE,IAAI,CAAC,6BAA6B,CAAC,CAAC;QAC7I,IAAI,UAAkB,CAAC;QACvB,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;YAC9B,uEAAuE;YACvE,UAAU,GAAG,CAAC,IAAI,IAAI,CAAC,aAAa,GAAG,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,0CAA0C;SACrG;aAAM,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;YACrC,UAAU,GAAG,QAAQ,CAAC;SACzB;aAAM;YACH,OAAO;SACV;QACD,OAAO,CAAC,qBAAqB,IAAI,UAAU,CAAC;QAC5C,OAAO,CAAC,UAAU,EAAE,CAAC;IACzB,CAAC;IAEM,uDAAa,GAApB;QACI,OAAO,IAAI,CAAC,cAAc,CAAC;IAC/B,CAAC;IAEa,yCAAS,GAAvB;QACI,OAAO,+BAA+B,CAAC,QAAQ,IAAI,+BAA+B,CAAC,QAAQ,CAAC,UAAU,CAAC;IAC3G,CAAC;IAEM,mEAAyB,GAAhC;QACI,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAC/B,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC9B,IAAI,CAAC,kBAAkB,EAAE,CAAC;IAC9B,CAAC;IAEc,qDAAqB,GAApC,UAAqC,UAAgC,EAAE,iBAAiD;QACpH,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,0DAA0D;QAC1D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,iBAAiB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/C,cAAc;YACd,IAAI,UAAU,KAAK,iBAAiB,CAAC,CAAC,CAAC,CAAC,UAAU,EAAE;gBAChD,OAAO,iBAAiB,CAAC,CAAC,CAAC,CAAC;aAC/B;YACD,+BAA+B;YAC/B,IAAI,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,EAAE;gBACxF,SAAS;aACZ;YACD,yBAAyB;YACzB,KAAK,IAAI,GAAG,IAAI,UAAU,EAAE;gBACxB,IAAU,UAAW,CAAC,GAAG,CAAC,IAAU,iBAAiB,CAAC,CAAC,CAAC,CAAC,UAAW,CAAC,GAAG,CAAC,EAAE;oBACvE,QAAQ,GAAG,IAAI,CAAC;oBAChB,MAAM;iBACT;aACJ;YACD,IAAI,CAAC,QAAQ,EAAE,EAAE,QAAQ;gBACrB,OAAO,iBAAiB,CAAC,CAAC,CAAC,CAAC;aAC/B;YACD,QAAQ,GAAG,KAAK,CAAC;SACpB;QACD,gCAAgC;QAChC,IAAI,UAAU,GAAG,IAAI,kDAAuB,CAAC,UAAU,CAAC,CAAC;QACzD,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACnC,OAAO,UAAU,CAAC;IACtB,CAAC;IAEO,8DAAoB,GAA5B;QACI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,+BAA+B,CAAC,0BAA0B,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACxF,IAAI,cAAc,GAAG,+BAA+B,CAAC,0BAA0B,CAAC,CAAC,CAAC,CAAC;YACnF,cAAc,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,CAAC;YAChC,IAAI,gBAAgB,GAAG,CAAC,cAAc,CAAC,UAAU,GAAG,cAAc,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YACxF,IAAI,SAAS,GAAG,cAAc,CAAC,IAAI,GAAG,cAAc,CAAC,QAAQ,CAAC;YAC9D,IAAI,2BAA2B,GAAG,CAAC,CAAC,cAAc,CAAC,qBAAqB,GAAG,cAAc,CAAC,yBAAyB,CAAC,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC;YAC9I,cAAc,CAAC,yBAAyB,GAAG,cAAc,CAAC,qBAAqB,CAAC,CAAC,QAAQ;YACzF,IAAI,SAAS,GAAG,CAAC,IAAI,gBAAgB,GAAG,CAAC,EAAE;gBACvC,IAAI,CAAC,yBAAyB,CAAC;oBAC3B,IAAI,EAAE,sBAAsB;oBAC5B,UAAU,EAAE,cAAc,CAAC,UAAU;oBACrC,KAAK,EAAE,2BAA2B;oBAClC,KAAK,EAAE,gBAAgB;oBACvB,mBAAmB,EAAE,SAAS;oBAC9B,UAAU,EAAE,SAAS,CAAC,QAAQ,CAAC,iBAAiB;iBACnD,CAAC,CAAC;aACN;YACD,oBAAoB;YACpB,cAAc,CAAC,cAAc,GAAG,cAAc,CAAC,UAAU,CAAC;YAC1D,cAAc,CAAC,QAAQ,GAAG,cAAc,CAAC,IAAI,CAAC;SACjD;IACL,CAAC;IAEO,iEAAuB,GAA/B;QACI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,+BAA+B,CAAC,6BAA6B,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC3F,IAAI,cAAc,GAAG,+BAA+B,CAAC,6BAA6B,CAAC,CAAC,CAAC,CAAC;YACtF,cAAc,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,CAAC;YAChC,IAAI,oBAAoB,GAAG,CAAC,cAAc,CAAC,UAAU,GAAG,cAAc,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YAC5F,IAAI,SAAS,GAAG,cAAc,CAAC,IAAI,GAAG,cAAc,CAAC,QAAQ,CAAC;YAC9D,IAAI,8BAA8B,GAAG,CAAC,CAAC,cAAc,CAAC,qBAAqB,GAAG,cAAc,CAAC,yBAAyB,CAAC,GAAG,oBAAoB,CAAC,IAAI,CAAC,CAAC;YACrJ,cAAc,CAAC,yBAAyB,GAAG,cAAc,CAAC,qBAAqB,CAAC,CAAC,QAAQ;YACzF,IAAI,SAAS,GAAG,CAAC,IAAI,oBAAoB,GAAG,CAAC,EAAE;gBAC3C,IAAI,CAAC,yBAAyB,CAAC;oBAC3B,IAAI,EAAE,qBAAqB;oBAC3B,UAAU,EAAE,cAAc,CAAC,UAAU;oBACrC,KAAK,EAAE,8BAA8B;oBACrC,KAAK,EAAE,oBAAoB;oBAC3B,mBAAmB,EAAE,SAAS;oBAC9B,UAAU,EAAE,SAAS,CAAC,QAAQ,CAAC,qBAAqB;iBACvD,CAAC,CAAC;aACN;YACD,oBAAoB;YACpB,cAAc,CAAC,cAAc,GAAG,cAAc,CAAC,UAAU,CAAC;YAC1D,cAAc,CAAC,QAAQ,GAAG,cAAc,CAAC,IAAI,CAAC;SACjD;IACL,CAAC;IAEO,gEAAsB,GAA9B;QACI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,+BAA+B,CAAC,4BAA4B,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC1F,IAAI,cAAc,GAAG,+BAA+B,CAAC,4BAA4B,CAAC,CAAC,CAAC,CAAC;YACrF,cAAc,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,CAAC;YAChC,IAAI,kBAAkB,GAAG,CAAC,cAAc,CAAC,UAAU,GAAG,cAAc,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YAC1F,IAAI,SAAS,GAAG,cAAc,CAAC,IAAI,GAAG,cAAc,CAAC,QAAQ,CAAC;YAC9D,IAAI,SAAS,GAAG,CAAC,IAAI,kBAAkB,GAAG,CAAC,EAAE;gBACzC,IAAI,CAAC,yBAAyB,CAAC;oBAC3B,IAAI,EAAE,YAAY;oBAClB,UAAU,EAAE,cAAc,CAAC,UAAU;oBACrC,KAAK,EAAE,kBAAkB;oBACzB,KAAK,EAAE,kBAAkB;oBACzB,mBAAmB,EAAE,SAAS;oBAC9B,UAAU,EAAE,SAAS,CAAC,QAAQ,CAAC,gBAAgB;iBAClD,CAAC,CAAC;aACN;YACD,oBAAoB;YACpB,cAAc,CAAC,cAAc,GAAG,cAAc,CAAC,UAAU,CAAC;YAC1D,cAAc,CAAC,QAAQ,GAAG,cAAc,CAAC,IAAI,CAAC;SACjD;IACL,CAAC;IAEO,4DAAkB,GAA1B;QACI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,+BAA+B,CAAC,wBAAwB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACtF,IAAI,cAAc,GAAG,+BAA+B,CAAC,wBAAwB,CAAC,CAAC,CAAC,CAAC;YACjF,cAAc,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,CAAC;YAChC,IAAI,cAAc,GAAG,CAAC,cAAc,CAAC,UAAU,GAAG,cAAc,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YACtF,IAAI,SAAS,GAAG,cAAc,CAAC,IAAI,GAAG,cAAc,CAAC,QAAQ,CAAC;YAC9D,IAAI,SAAS,GAAG,CAAC,IAAI,cAAc,GAAG,CAAC,EAAE;gBACrC,IAAI,CAAC,yBAAyB,CAAC;oBAC3B,IAAI,EAAE,QAAQ;oBACd,UAAU,EAAE,cAAc,CAAC,UAAU;oBACrC,KAAK,EAAE,cAAc;oBACrB,KAAK,EAAE,cAAc;oBACrB,mBAAmB,EAAE,SAAS;oBAC9B,UAAU,EAAE,SAAS,CAAC,QAAQ,CAAC,YAAY;iBAC9C,CAAC,CAAC;aACN;YACD,oBAAoB;YACpB,cAAc,CAAC,cAAc,GAAG,cAAc,CAAC,UAAU,CAAC;YAC1D,cAAc,CAAC,QAAQ,GAAG,cAAc,CAAC,IAAI,CAAC;SACjD;IACL,CAAC;IAEO,mEAAyB,GAAjC,UAAkC,MAAwB;QACtD,0BAA0B;QAC1B,IAAI,gBAAgB,GAAQ,EAAE,CAAC;QAC/B,KAAK,IAAI,GAAG,IAAI,MAAM,CAAC,UAAU,EAAE;YAC/B,gBAAgB,CAAC,6DAAgC,CAAC,GAA8B,CAAC,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;SAC/G;QACD,gBAAgB,yBACT,gBAAgB,KACnB,cAAc,EAAE,MAAM,CAAC,UAAU,EACjC,2BAA2B,EAAE,MAAM,CAAC,MAAM,CAAC,mBAAmB,CAAC,EAC/D,qBAAqB,EAAE,MAAM,GAChC,CAAC;QAEF,IAAI,SAAS,GAA8B;YACvC,IAAI,EAAE,MAAM,CAAC,IAAI;YACjB,KAAK,EAAE,MAAM,CAAC,KAAK;YACnB,KAAK,EAAE,MAAM,CAAC,KAAK;YACnB,UAAU,EAAE,gBAAgB;YAC5B,IAAI,EAAE,aAAa;SACtB,CAAC;QACF,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;IACxC,CAAC;IAEM,iDAAO,GAAd;QACI,+BAA+B,CAAC,QAAQ,GAAG,IAAI,CAAC;QAChD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACnB,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;IAChC,CAAC;IACL,sCAAC;AAAD,CAAC,AA7QD,IA6QC;AAED,iBAAS,+BAA+B,CAAC","sourcesContent":["import TelemetryClient = require(\"../Library/TelemetryClient\");\r\nimport Constants = require(\"../Declarations/Constants\");\r\n\r\nimport { AggregatedMetric } from \"../Declarations/Metrics/AggregatedMetric\";\r\nimport { AggregatedMetricCounter } from \"../Declarations/Metrics/AggregatedMetricCounters\";\r\nimport {\r\n    MetricBaseDimensions,\r\n    MetricDependencyDimensions,\r\n    MetricExceptionDimensions,\r\n    MetricRequestDimensions,\r\n    MetricTraceDimensions,\r\n    PreaggregatedMetricPropertyNames,\r\n    MetricDimensionTypeKeys\r\n} from \"../Declarations/Metrics/AggregatedMetricDimensions\";\r\nimport * as Contracts from \"../Declarations/Contracts\";\r\n\r\n\r\nclass AutoCollectPreAggregatedMetrics {\r\n\r\n    public static INSTANCE: AutoCollectPreAggregatedMetrics;\r\n    private _collectionInterval: number;\r\n    private _client: TelemetryClient;\r\n    private _handle: NodeJS.Timer;\r\n    private _isEnabled: boolean;\r\n    private _isInitialized: boolean;\r\n\r\n    private static _dependencyCountersCollection: Array<AggregatedMetricCounter>;\r\n    private static _requestCountersCollection: Array<AggregatedMetricCounter>;\r\n    private static _exceptionCountersCollection: Array<AggregatedMetricCounter>;\r\n    private static _traceCountersCollection: Array<AggregatedMetricCounter>;\r\n\r\n    /**\r\n     * @param client - Telemetry Client\r\n     * @param collectionInterval - Metric collection interval in ms\r\n     */\r\n    constructor(client: TelemetryClient, collectionInterval = 60000) {\r\n        if (!AutoCollectPreAggregatedMetrics.INSTANCE) {\r\n            AutoCollectPreAggregatedMetrics.INSTANCE = this;\r\n        }\r\n\r\n        this._isInitialized = false;\r\n        AutoCollectPreAggregatedMetrics._dependencyCountersCollection = [];\r\n        AutoCollectPreAggregatedMetrics._requestCountersCollection = [];\r\n        AutoCollectPreAggregatedMetrics._exceptionCountersCollection = [];\r\n        AutoCollectPreAggregatedMetrics._traceCountersCollection = [];\r\n        this._client = client;\r\n        this._collectionInterval = collectionInterval;\r\n    }\r\n\r\n    public enable(isEnabled: boolean, collectionInterval?: number) {\r\n        this._isEnabled = isEnabled;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._isInitialized = true;\r\n        }\r\n\r\n        if (isEnabled) {\r\n            if (!this._handle) {\r\n                this._collectionInterval = collectionInterval || this._collectionInterval;\r\n                this._handle = setInterval(() => this.trackPreAggregatedMetrics(), this._collectionInterval);\r\n                this._handle.unref(); // Allow the app to terminate even while this loop is going on\r\n            }\r\n        } else {\r\n            if (this._handle) {\r\n                clearInterval(this._handle);\r\n                this._handle = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static countException(dimensions: MetricExceptionDimensions) {\r\n        if (!AutoCollectPreAggregatedMetrics.isEnabled()) {\r\n            return;\r\n        }\r\n        let counter: AggregatedMetricCounter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._exceptionCountersCollection);\r\n        counter.totalCount++;\r\n    }\r\n\r\n    public static countTrace(dimensions: MetricTraceDimensions) {\r\n        if (!AutoCollectPreAggregatedMetrics.isEnabled()) {\r\n            return;\r\n        }\r\n        let counter: AggregatedMetricCounter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._traceCountersCollection);\r\n        counter.totalCount++;\r\n    }\r\n\r\n    public static countRequest(duration: number | string, dimensions: MetricRequestDimensions) {\r\n        if (!AutoCollectPreAggregatedMetrics.isEnabled()) {\r\n            return;\r\n        }\r\n        let durationMs: number;\r\n        let counter: AggregatedMetricCounter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._requestCountersCollection);\r\n        if (typeof duration === \"string\") {\r\n            // dependency duration is passed in as \"00:00:00.123\" by autocollectors\r\n            durationMs = +new Date(\"1970-01-01T\" + duration + \"Z\"); // convert to num ms, returns NaN if wrong\r\n        } else if (typeof duration === \"number\") {\r\n            durationMs = duration;\r\n        } else {\r\n            return;\r\n        }\r\n        counter.intervalExecutionTime += durationMs;\r\n        counter.totalCount++;\r\n    }\r\n\r\n    public static countDependency(duration: number | string, dimensions: MetricDependencyDimensions) {\r\n        if (!AutoCollectPreAggregatedMetrics.isEnabled()) {\r\n            return;\r\n        }\r\n        let counter: AggregatedMetricCounter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._dependencyCountersCollection);\r\n        let durationMs: number;\r\n        if (typeof duration === \"string\") {\r\n            // dependency duration is passed in as \"00:00:00.123\" by autocollectors\r\n            durationMs = +new Date(\"1970-01-01T\" + duration + \"Z\"); // convert to num ms, returns NaN if wrong\r\n        } else if (typeof duration === \"number\") {\r\n            durationMs = duration;\r\n        } else {\r\n            return;\r\n        }\r\n        counter.intervalExecutionTime += durationMs;\r\n        counter.totalCount++;\r\n    }\r\n\r\n    public isInitialized() {\r\n        return this._isInitialized;\r\n    }\r\n\r\n    public static isEnabled() {\r\n        return AutoCollectPreAggregatedMetrics.INSTANCE && AutoCollectPreAggregatedMetrics.INSTANCE._isEnabled;\r\n    }\r\n\r\n    public trackPreAggregatedMetrics() {\r\n        this._trackRequestMetrics();\r\n        this._trackDependencyMetrics();\r\n        this._trackExceptionMetrics();\r\n        this._trackTraceMetrics();\r\n    }\r\n\r\n    private static _getAggregatedCounter(dimensions: MetricBaseDimensions, counterCollection: Array<AggregatedMetricCounter>): AggregatedMetricCounter {\r\n        let notMatch = false;\r\n        // Check if counter with specified dimensions is available\r\n        for (let i = 0; i < counterCollection.length; i++) {\r\n            // Same object\r\n            if (dimensions === counterCollection[i].dimensions) {\r\n                return counterCollection[i];\r\n            }\r\n            // Diferent number of keys skip\r\n            if (Object.keys(dimensions).length !== Object.keys(counterCollection[i].dimensions).length) {\r\n                continue;\r\n            }\r\n            // Check dimension values\r\n            for (let dim in dimensions) {\r\n                if ((<any>dimensions)[dim] != (<any>counterCollection[i].dimensions)[dim]) {\r\n                    notMatch = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!notMatch) { // Found\r\n                return counterCollection[i];\r\n            }\r\n            notMatch = false;\r\n        }\r\n        // Create a new one if not found\r\n        let newCounter = new AggregatedMetricCounter(dimensions);\r\n        counterCollection.push(newCounter);\r\n        return newCounter;\r\n    }\r\n\r\n    private _trackRequestMetrics() {\r\n        for (let i = 0; i < AutoCollectPreAggregatedMetrics._requestCountersCollection.length; i++) {\r\n            var currentCounter = AutoCollectPreAggregatedMetrics._requestCountersCollection[i];\r\n            currentCounter.time = +new Date;\r\n            var intervalRequests = (currentCounter.totalCount - currentCounter.lastTotalCount) || 0;\r\n            var elapsedMs = currentCounter.time - currentCounter.lastTime;\r\n            var averageRequestExecutionTime = ((currentCounter.intervalExecutionTime - currentCounter.lastIntervalExecutionTime) / intervalRequests) || 0;\r\n            currentCounter.lastIntervalExecutionTime = currentCounter.intervalExecutionTime; // reset\r\n            if (elapsedMs > 0 && intervalRequests > 0) {\r\n                this._trackPreAggregatedMetric({\r\n                    name: \"Server response time\",\r\n                    dimensions: currentCounter.dimensions,\r\n                    value: averageRequestExecutionTime,\r\n                    count: intervalRequests,\r\n                    aggregationInterval: elapsedMs,\r\n                    metricType: Constants.MetricId.REQUESTS_DURATION\r\n                });\r\n            }\r\n            // Set last counters\r\n            currentCounter.lastTotalCount = currentCounter.totalCount;\r\n            currentCounter.lastTime = currentCounter.time;\r\n        }\r\n    }\r\n\r\n    private _trackDependencyMetrics() {\r\n        for (let i = 0; i < AutoCollectPreAggregatedMetrics._dependencyCountersCollection.length; i++) {\r\n            var currentCounter = AutoCollectPreAggregatedMetrics._dependencyCountersCollection[i];\r\n            currentCounter.time = +new Date;\r\n            var intervalDependencies = (currentCounter.totalCount - currentCounter.lastTotalCount) || 0;\r\n            var elapsedMs = currentCounter.time - currentCounter.lastTime;\r\n            var averageDependencyExecutionTime = ((currentCounter.intervalExecutionTime - currentCounter.lastIntervalExecutionTime) / intervalDependencies) || 0;\r\n            currentCounter.lastIntervalExecutionTime = currentCounter.intervalExecutionTime; // reset\r\n            if (elapsedMs > 0 && intervalDependencies > 0) {\r\n                this._trackPreAggregatedMetric({\r\n                    name: \"Dependency duration\",\r\n                    dimensions: currentCounter.dimensions,\r\n                    value: averageDependencyExecutionTime,\r\n                    count: intervalDependencies,\r\n                    aggregationInterval: elapsedMs,\r\n                    metricType: Constants.MetricId.DEPENDENCIES_DURATION\r\n                });\r\n            }\r\n            // Set last counters\r\n            currentCounter.lastTotalCount = currentCounter.totalCount;\r\n            currentCounter.lastTime = currentCounter.time;\r\n        }\r\n    }\r\n\r\n    private _trackExceptionMetrics() {\r\n        for (let i = 0; i < AutoCollectPreAggregatedMetrics._exceptionCountersCollection.length; i++) {\r\n            var currentCounter = AutoCollectPreAggregatedMetrics._exceptionCountersCollection[i];\r\n            currentCounter.time = +new Date;\r\n            var intervalExceptions = (currentCounter.totalCount - currentCounter.lastTotalCount) || 0;\r\n            var elapsedMs = currentCounter.time - currentCounter.lastTime;\r\n            if (elapsedMs > 0 && intervalExceptions > 0) {\r\n                this._trackPreAggregatedMetric({\r\n                    name: \"Exceptions\",\r\n                    dimensions: currentCounter.dimensions,\r\n                    value: intervalExceptions,\r\n                    count: intervalExceptions,\r\n                    aggregationInterval: elapsedMs,\r\n                    metricType: Constants.MetricId.EXCEPTIONS_COUNT\r\n                });\r\n            }\r\n            // Set last counters\r\n            currentCounter.lastTotalCount = currentCounter.totalCount;\r\n            currentCounter.lastTime = currentCounter.time;\r\n        }\r\n    }\r\n\r\n    private _trackTraceMetrics() {\r\n        for (let i = 0; i < AutoCollectPreAggregatedMetrics._traceCountersCollection.length; i++) {\r\n            var currentCounter = AutoCollectPreAggregatedMetrics._traceCountersCollection[i];\r\n            currentCounter.time = +new Date;\r\n            var intervalTraces = (currentCounter.totalCount - currentCounter.lastTotalCount) || 0;\r\n            var elapsedMs = currentCounter.time - currentCounter.lastTime;\r\n            if (elapsedMs > 0 && intervalTraces > 0) {\r\n                this._trackPreAggregatedMetric({\r\n                    name: \"Traces\",\r\n                    dimensions: currentCounter.dimensions,\r\n                    value: intervalTraces,\r\n                    count: intervalTraces,\r\n                    aggregationInterval: elapsedMs,\r\n                    metricType: Constants.MetricId.TRACES_COUNT\r\n                });\r\n            }\r\n            // Set last counters\r\n            currentCounter.lastTotalCount = currentCounter.totalCount;\r\n            currentCounter.lastTime = currentCounter.time;\r\n        }\r\n    }\r\n\r\n    private _trackPreAggregatedMetric(metric: AggregatedMetric) {\r\n        // Build metric properties\r\n        let metricProperties: any = {};\r\n        for (let dim in metric.dimensions) {\r\n            metricProperties[PreaggregatedMetricPropertyNames[dim as MetricDimensionTypeKeys]] = metric.dimensions[dim];\r\n        }\r\n        metricProperties = {\r\n            ...metricProperties,\r\n            \"_MS.MetricId\": metric.metricType,\r\n            \"_MS.AggregationIntervalMs\": String(metric.aggregationInterval),\r\n            \"_MS.IsAutocollected\": \"True\"\r\n        };\r\n\r\n        let telemetry: Contracts.MetricTelemetry = {\r\n            name: metric.name,\r\n            value: metric.value,\r\n            count: metric.count,\r\n            properties: metricProperties,\r\n            kind: \"Aggregation\"\r\n        };\r\n        this._client.trackMetric(telemetry);\r\n    }\r\n\r\n    public dispose() {\r\n        AutoCollectPreAggregatedMetrics.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    }\r\n}\r\n\r\nexport = AutoCollectPreAggregatedMetrics;\r\n"]}