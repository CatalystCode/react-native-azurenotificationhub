{"version":3,"file":"Sender.js","sourceRoot":"","sources":["../../Library/Sender.ts"],"names":[],"mappings":"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","sourcesContent":["import fs = require(\"fs\");\r\nimport http = require(\"http\");\r\nimport os = require(\"os\");\r\nimport path = require(\"path\");\r\nimport zlib = require(\"zlib\");\r\n\r\nimport AuthorizationHandler = require(\"./AuthorizationHandler\");\r\nimport Config = require(\"./Config\")\r\nimport Contracts = require(\"../Declarations/Contracts\");\r\nimport Constants = require(\"../Declarations/Constants\");\r\nimport AutoCollectHttpDependencies = require(\"../AutoCollection/HttpDependencies\");\r\nimport Statsbeat = require(\"../AutoCollection/Statsbeat\");\r\nimport FileSystemHelper = require(\"./FileSystemHelper\");\r\nimport Util = require(\"./Util\");\r\nimport { URL } from \"url\";\r\nimport Logging = require(\"./Logging\");\r\nimport { FileAccessControl } from \"./FileAccessControl\";\r\n\r\nconst legacyThrottleStatusCode = 439; //  - Too many requests and refresh cache\r\nconst throttleStatusCode = 402; // Monthly Quota Exceeded (new SDK)\r\nconst RESPONSE_CODES_INDICATING_REACHED_BREEZE = [200, 206, 402, 408, 429, 439, 500];\r\n\r\nclass Sender {\r\n    private static TAG = \"Sender\";\r\n    // the amount of time the SDK will wait between resending cached data, this buffer is to avoid any throttling from the service side\r\n    public static WAIT_BETWEEN_RESEND = 60 * 1000; // 1 minute\r\n    public static MAX_BYTES_ON_DISK = 50 * 1024 * 1024; // 50 mb\r\n    public static MAX_CONNECTION_FAILURES_BEFORE_WARN = 5;\r\n    public static CLEANUP_TIMEOUT = 60 * 60 * 1000; // 1 hour\r\n    public static FILE_RETEMPTION_PERIOD = 7 * 24 * 60 * 60 * 1000; // 7 days\r\n    public static TEMPDIR_PREFIX: string = \"appInsights-node\";\r\n    public static HTTP_TIMEOUT: number = 20000; // 20 seconds\r\n\r\n    private _config: Config;\r\n    private _isStatsbeatSender: boolean;\r\n    private _shutdownStatsbeat: () => void;\r\n    private _failedToIngestCounter: number;\r\n    private _statsbeatHasReachedIngestionAtLeastOnce: boolean;\r\n    private _statsbeat: Statsbeat;\r\n    private _onSuccess: (response: string) => void;\r\n    private _onError: (error: Error) => void;\r\n    private _getAuthorizationHandler: (config: Config) => AuthorizationHandler;\r\n    private _enableDiskRetryMode: boolean;\r\n    private _numConsecutiveFailures: number;\r\n    private _numConsecutiveRedirects: number;\r\n    private _resendTimer: NodeJS.Timer | null;\r\n    private _fileCleanupTimer: NodeJS.Timer;\r\n    private _redirectedHost: string = null;\r\n    private _tempDir: string;\r\n    private _requestTimedOut: boolean;\r\n    protected _resendInterval: number;\r\n    protected _maxBytesOnDisk: number;\r\n\r\n    constructor(config: Config, getAuthorizationHandler?: (config: Config) => AuthorizationHandler, onSuccess?: (response: string) => void, onError?: (error: Error) => void, statsbeat?: Statsbeat, isStatsbeatSender?: boolean, shutdownStatsbeat?: () => void) {\r\n        this._config = config;\r\n        this._onSuccess = onSuccess;\r\n        this._onError = onError;\r\n        this._statsbeat = statsbeat;\r\n        this._enableDiskRetryMode = false;\r\n        this._resendInterval = Sender.WAIT_BETWEEN_RESEND;\r\n        this._maxBytesOnDisk = Sender.MAX_BYTES_ON_DISK;\r\n        this._numConsecutiveFailures = 0;\r\n        this._numConsecutiveRedirects = 0;\r\n        this._resendTimer = null;\r\n        this._getAuthorizationHandler = getAuthorizationHandler;\r\n        this._fileCleanupTimer = null;\r\n        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows\r\n        this._tempDir = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);\r\n        this._isStatsbeatSender = isStatsbeatSender || false;\r\n        this._shutdownStatsbeat = shutdownStatsbeat;\r\n        this._failedToIngestCounter = 0;\r\n        this._statsbeatHasReachedIngestionAtLeastOnce = false;\r\n    }\r\n\r\n    /**\r\n    * Enable or disable offline mode\r\n    */\r\n    public setDiskRetryMode(value: boolean, resendInterval?: number, maxBytesOnDisk?: number) {\r\n        if (value) {\r\n            FileAccessControl.checkFileProtection(); // Only check file protection when disk retry is enabled\r\n        }\r\n        this._enableDiskRetryMode = FileAccessControl.OS_PROVIDES_FILE_PROTECTION && value;\r\n        if (typeof resendInterval === \"number\" && resendInterval >= 0) {\r\n            this._resendInterval = Math.floor(resendInterval);\r\n        }\r\n        if (typeof maxBytesOnDisk === \"number\" && maxBytesOnDisk >= 0) {\r\n            this._maxBytesOnDisk = Math.floor(maxBytesOnDisk);\r\n        }\r\n\r\n        if (value && !FileAccessControl.OS_PROVIDES_FILE_PROTECTION) {\r\n            this._enableDiskRetryMode = false;\r\n            this._logWarn(\"Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.\")\r\n        }\r\n        if (this._enableDiskRetryMode) {\r\n            if (this._statsbeat) {\r\n                this._statsbeat.addFeature(Constants.StatsbeatFeature.DISK_RETRY);\r\n            }\r\n            // Starts file cleanup task\r\n            if (!this._fileCleanupTimer) {\r\n                this._fileCleanupTimer = setTimeout(() => { this._fileCleanupTask(); }, Sender.CLEANUP_TIMEOUT);\r\n                this._fileCleanupTimer.unref();\r\n            }\r\n        }\r\n        else {\r\n            if (this._statsbeat) {\r\n                this._statsbeat.removeFeature(Constants.StatsbeatFeature.DISK_RETRY);\r\n            }\r\n            if (this._fileCleanupTimer) {\r\n                clearTimeout(this._fileCleanupTimer);\r\n            }\r\n        }\r\n    }\r\n\r\n    public async send(envelopes: Contracts.EnvelopeTelemetry[], callback?: (v: string) => void) {\r\n        if (envelopes) {\r\n            var endpointUrl = this._redirectedHost || this._config.endpointUrl;\r\n\r\n            var endpointHost = new URL(endpointUrl).hostname;\r\n\r\n            // todo: investigate specifying an agent here: https://nodejs.org/api/http.html#http_class_http_agent\r\n            var options = {\r\n                method: \"POST\",\r\n                withCredentials: false,\r\n                headers: <{ [key: string]: string }>{\r\n                    \"Content-Type\": \"application/x-json-stream\"\r\n                }\r\n            };\r\n\r\n            let authHandler = this._getAuthorizationHandler ? this._getAuthorizationHandler(this._config) : null;\r\n            if (authHandler) {\r\n                if (this._statsbeat) {\r\n                    this._statsbeat.addFeature(Constants.StatsbeatFeature.AAD_HANDLING);\r\n                }\r\n                try {\r\n                    // Add bearer token\r\n                    await authHandler.addAuthorizationHeader(options);\r\n                }\r\n                catch (authError) {\r\n                    let errorMsg = \"Failed to get AAD bearer token for the Application.\";\r\n                    if (this._enableDiskRetryMode) {\r\n                        errorMsg += \"This batch of telemetry items will be retried. \";\r\n                        this._storeToDisk(envelopes);\r\n                    }\r\n                    errorMsg += \"Error:\" + authError.toString();\r\n                    this._logWarn(errorMsg);\r\n\r\n                    if (typeof callback === \"function\") {\r\n                        callback(errorMsg);\r\n                    }\r\n                    return; // If AAD auth fails do not send to Breeze\r\n                }\r\n            }\r\n\r\n            let batch: string = \"\";\r\n            envelopes.forEach(envelope => {\r\n                var payload: string = Util.stringify(envelope);\r\n                if (typeof payload !== \"string\") {\r\n                    return;\r\n                }\r\n                batch += payload + \"\\n\";\r\n            });\r\n            // Remove last \\n\r\n            if (batch.length > 0) {\r\n                batch = batch.substring(0, batch.length - 1);\r\n            }\r\n\r\n            let payload: Buffer = Buffer.from ? Buffer.from(batch) : new Buffer(batch);\r\n\r\n            zlib.gzip(payload, (err, buffer) => {\r\n                var dataToSend = buffer;\r\n                if (err) {\r\n                    this._logWarn(Util.dumpObj(err));\r\n                    dataToSend = payload; // something went wrong so send without gzip\r\n                    options.headers[\"Content-Length\"] = payload.length.toString();\r\n                } else {\r\n                    options.headers[\"Content-Encoding\"] = \"gzip\";\r\n                    options.headers[\"Content-Length\"] = buffer.length.toString();\r\n                }\r\n\r\n                this._logInfo(Util.dumpObj(options));\r\n\r\n                // Ensure this request is not captured by auto-collection.\r\n                (<any>options)[AutoCollectHttpDependencies.disableCollectionRequestOption] = true;\r\n\r\n                let startTime = +new Date();\r\n\r\n                var requestCallback = (res: http.ClientResponse) => {\r\n                    res.setEncoding(\"utf-8\");\r\n\r\n                    //returns empty if the data is accepted\r\n                    var responseString = \"\";\r\n                    res.on(\"data\", (data: string) => {\r\n                        responseString += data;\r\n                    });\r\n\r\n                    res.on(\"end\", () => {\r\n                        let endTime = +new Date();\r\n                        let duration = endTime - startTime;\r\n                        this._numConsecutiveFailures = 0;\r\n                        // Handling of Statsbeat instance sending data, should turn it off if is not able to reach ingestion endpoint\r\n                        if (this._isStatsbeatSender && !this._statsbeatHasReachedIngestionAtLeastOnce) {\r\n                            if (RESPONSE_CODES_INDICATING_REACHED_BREEZE.includes(res.statusCode)) {\r\n                                this._statsbeatHasReachedIngestionAtLeastOnce = true;\r\n                            }\r\n                            else {\r\n                                this._statsbeatFailedToIngest();\r\n                            }\r\n                        }\r\n                        if (this._statsbeat) {\r\n                            if (res.statusCode == throttleStatusCode || res.statusCode == legacyThrottleStatusCode) { // Throttle\r\n                                this._statsbeat.countThrottle(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, res.statusCode);\r\n                            }\r\n                            else {\r\n                                this._statsbeat.countRequest(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, duration, res.statusCode === 200, res.statusCode);\r\n                            }\r\n                        }\r\n                        if (this._enableDiskRetryMode) {\r\n                            // try to send any cached events if the user is back online\r\n                            if (res.statusCode === 200) {\r\n                                if (!this._resendTimer) {\r\n                                    this._resendTimer = setTimeout(() => {\r\n                                        this._resendTimer = null;\r\n                                        this._sendFirstFileOnDisk()\r\n                                    }, this._resendInterval);\r\n                                    this._resendTimer.unref();\r\n                                }\r\n                            } else if (this._isRetriable(res.statusCode)) {\r\n                                try {\r\n                                    if (this._statsbeat) {\r\n                                        this._statsbeat.countRetry(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, res.statusCode);\r\n                                    }\r\n                                    const breezeResponse = JSON.parse(responseString) as Contracts.BreezeResponse;\r\n                                    let filteredEnvelopes: Contracts.EnvelopeTelemetry[] = [];\r\n                                    if (breezeResponse.errors) {\r\n                                        breezeResponse.errors.forEach(error => {\r\n                                            // Only retry errors if 429, 500 or 503 response codes\r\n                                            if (error.statusCode == 429 || error.statusCode == 500 || error.statusCode == 503) {\r\n                                                filteredEnvelopes.push(envelopes[error.index]);\r\n                                            }\r\n                                        });\r\n                                        if (filteredEnvelopes.length > 0) {\r\n                                            this._storeToDisk(filteredEnvelopes);\r\n                                        }\r\n                                    }\r\n\r\n                                }\r\n                                catch (ex) {\r\n                                    this._storeToDisk(envelopes); // Retriable status code with not valid Breeze response\r\n                                }\r\n                            }\r\n                        }\r\n                        // Redirect handling\r\n                        if (res.statusCode === 307 || // Temporary Redirect\r\n                            res.statusCode === 308) { // Permanent Redirect\r\n                            this._numConsecutiveRedirects++;\r\n                            // To prevent circular redirects\r\n                            if (this._numConsecutiveRedirects < 10) {\r\n                                // Try to get redirect header\r\n                                const locationHeader = res.headers[\"location\"] ? res.headers[\"location\"].toString() : null;\r\n                                if (locationHeader) {\r\n                                    this._redirectedHost = locationHeader;\r\n                                    // Send to redirect endpoint as HTTPs library doesn't handle redirect automatically\r\n                                    this.send(envelopes, callback);\r\n                                }\r\n                            }\r\n                            else {\r\n                                const circularRedirectError: Error = { name: \"Circular Redirect\", message: \"Error sending telemetry because of circular redirects.\" }\r\n                                if (this._statsbeat) {\r\n                                    this._statsbeat.countException(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, circularRedirectError);\r\n                                }\r\n                                if (typeof callback === \"function\") {\r\n                                    callback(\"Error sending telemetry because of circular redirects.\");\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                        else {\r\n                            this._numConsecutiveRedirects = 0;\r\n                            if (typeof callback === \"function\") {\r\n                                callback(responseString);\r\n                            }\r\n                            this._logInfo(responseString);\r\n                            if (typeof this._onSuccess === \"function\") {\r\n                                this._onSuccess(responseString);\r\n                            }\r\n                        }\r\n                    });\r\n                };\r\n\r\n                var req = Util.makeRequest(this._config, endpointUrl, options, requestCallback);\r\n\r\n                // Needed as of Node.js v13 default timeouts on HTTP requests are no longer default\r\n                // Timeout should trigger the request on error function to run\r\n                req.setTimeout(Sender.HTTP_TIMEOUT, () => {\r\n                    this._requestTimedOut = true;\r\n                    req.abort();\r\n                });\r\n\r\n                req.on(\"error\", (error: Error) => {\r\n                    if (this._isStatsbeatSender && !this._statsbeatHasReachedIngestionAtLeastOnce) {\r\n                        this._statsbeatFailedToIngest();\r\n                    }\r\n                    // todo: handle error codes better (group to recoverable/non-recoverable and persist)\r\n                    this._numConsecutiveFailures++;\r\n                    if (this._statsbeat) {\r\n                        this._statsbeat.countException(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, error);\r\n                    }\r\n\r\n                    // Only use warn level if retries are disabled or we've had some number of consecutive failures sending data\r\n                    // This is because warn level is printed in the console by default, and we don't want to be noisy for transient and self-recovering errors\r\n                    // Continue informing on each failure if verbose logging is being used\r\n                    if (!this._enableDiskRetryMode || this._numConsecutiveFailures > 0 && this._numConsecutiveFailures % Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN === 0) {\r\n                        let notice = \"Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:\";\r\n                        if (this._enableDiskRetryMode) {\r\n                            notice = `Ingestion endpoint could not be reached ${this._numConsecutiveFailures} consecutive times. There may be resulting telemetry loss. Most recent error:`;\r\n                        }\r\n                        this._logWarn(notice, Util.dumpObj(error));\r\n                    } else {\r\n                        let notice = \"Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:\";\r\n                        this._logInfo(notice, Util.dumpObj(error));\r\n                    }\r\n                    this._onErrorHelper(error);\r\n\r\n                    if (typeof callback === \"function\") {\r\n                        if (error) {\r\n                            // If the error type is a timeout we want to provide more meaningful output\r\n                            if (this._requestTimedOut) {\r\n                                error.name = \"telemetry timeout\";\r\n                                error.message = \"telemetry request timed out\";\r\n                            }\r\n                            callback(Util.dumpObj(error));\r\n                        }\r\n                        else {\r\n                            callback(\"Error sending telemetry\");\r\n                        }\r\n                    }\r\n\r\n                    if (this._enableDiskRetryMode) {\r\n                        this._storeToDisk(envelopes);\r\n                    }\r\n                });\r\n\r\n                req.write(dataToSend);\r\n                req.end();\r\n            });\r\n        }\r\n    }\r\n\r\n    public saveOnCrash(envelopes: Contracts.EnvelopeTelemetry[]) {\r\n        if (this._enableDiskRetryMode) {\r\n            this._storeToDiskSync(Util.stringify(envelopes));\r\n        }\r\n    }\r\n\r\n    private _isRetriable(statusCode: number) {\r\n        return (\r\n            statusCode === 206 || // Partial Accept\r\n            statusCode === 401 || // Unauthorized\r\n            statusCode === 403 || // Forbidden\r\n            statusCode === 408 || // Timeout\r\n            statusCode === 429 || // Too many requests\r\n            statusCode === 500 || // Server Error\r\n            statusCode === 502 || // Bad Gateway\r\n            statusCode === 503 || // Server Unavailable\r\n            statusCode === 504 // Gateway Timeout\r\n        );\r\n    }\r\n\r\n    private _logInfo(message?: any, ...optionalParams: any[]) {\r\n        if (!this._isStatsbeatSender) {\r\n            Logging.info(Sender.TAG, message, optionalParams);\r\n        }\r\n    }\r\n\r\n    private _logWarn(message?: any, ...optionalParams: any[]) {\r\n        if (!this._isStatsbeatSender) {\r\n            Logging.warn(Sender.TAG, message, optionalParams);\r\n        }\r\n    }\r\n\r\n    private _statsbeatFailedToIngest() {\r\n        if (this._shutdownStatsbeat) { // Check if callback is available\r\n            this._failedToIngestCounter++;\r\n            if (this._failedToIngestCounter >= 3) {\r\n                this._shutdownStatsbeat();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores the payload as a json file on disk in the temp directory\r\n     */\r\n    private async _storeToDisk(envelopes: Contracts.EnvelopeTelemetry[]): Promise<void> {\r\n        try {\r\n            this._logInfo(\"Checking existence of data storage directory: \" + this._tempDir);\r\n            await FileSystemHelper.confirmDirExists(this._tempDir);\r\n        }\r\n        catch (ex) {\r\n            this._logWarn(\"Failed to create folder to put telemetry: \" + Util.dumpObj(ex));\r\n            this._onErrorHelper(ex);\r\n            return;\r\n        }\r\n        try {\r\n            await FileAccessControl.applyACLRules(this._tempDir);\r\n        }\r\n        catch (ex) {\r\n            this._logWarn(\"Failed to apply file access control to folder: \" + Util.dumpObj(ex));\r\n            this._onErrorHelper(ex);\r\n            return;\r\n        }\r\n        try {\r\n            let size = await FileSystemHelper.getShallowDirectorySize(this._tempDir);\r\n            if (size > this._maxBytesOnDisk) {\r\n                this._logWarn(\"Not saving data due to max size limit being met. Directory size in bytes is: \" + size);\r\n                return;\r\n            }\r\n            //create file - file name for now is the timestamp, a better approach would be a UUID but that\r\n            //would require an external dependency\r\n            var fileName = new Date().getTime() + \".ai.json\";\r\n            var fileFullPath = path.join(this._tempDir, fileName);\r\n\r\n            // Mode 600 is w/r for creator and no read access for others (only applies on *nix)\r\n            // For Windows, ACL rules are applied to the entire directory (see logic in _confirmDirExists and _applyACLRules)\r\n            this._logInfo(\"saving data to disk at: \" + fileFullPath);\r\n            FileSystemHelper.writeFileAsync(fileFullPath, Util.stringify(envelopes), { mode: 0o600 });\r\n        }\r\n        catch (ex) {\r\n            this._logWarn(\"Failed to persist telemetry to disk: \" + Util.dumpObj(ex));\r\n            this._onErrorHelper(ex);\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores the payload as a json file on disk using sync file operations\r\n     * this is used when storing data before crashes\r\n     */\r\n    private _storeToDiskSync(payload: any) {\r\n        try {\r\n            this._logInfo(\"Checking existence of data storage directory: \" + this._tempDir);\r\n            if (!fs.existsSync(this._tempDir)) {\r\n                fs.mkdirSync(this._tempDir);\r\n            }\r\n\r\n            // Make sure permissions are valid\r\n            FileAccessControl.applyACLRulesSync(this._tempDir);\r\n\r\n            let dirSize = FileSystemHelper.getShallowDirectorySizeSync(this._tempDir);\r\n            if (dirSize > this._maxBytesOnDisk) {\r\n                this._logInfo(\"Not saving data due to max size limit being met. Directory size in bytes is: \" + dirSize);\r\n                return;\r\n            }\r\n\r\n            //create file - file name for now is the timestamp, a better approach would be a UUID but that\r\n            //would require an external dependency\r\n            var fileName = new Date().getTime() + \".ai.json\";\r\n            var fileFullPath = path.join(this._tempDir, fileName);\r\n\r\n            // Mode 600 is w/r for creator and no access for anyone else (only applies on *nix)\r\n            this._logInfo(\"saving data before crash to disk at: \" + fileFullPath);\r\n            fs.writeFileSync(fileFullPath, payload, { mode: 0o600 });\r\n\r\n        } catch (error) {\r\n            this._logWarn(\"Error while saving data to disk: \" + Util.dumpObj(error));\r\n            this._onErrorHelper(error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for temp telemetry files\r\n     * reads the first file if exist, deletes it and tries to send its load\r\n     */\r\n    private async _sendFirstFileOnDisk(): Promise<void> {\r\n        try {\r\n            let files = await FileSystemHelper.readdirAsync(this._tempDir);\r\n            files = files.filter(f => path.basename(f).indexOf(\".ai.json\") > -1);\r\n            if (files.length > 0) {\r\n                var firstFile = files[0];\r\n                var filePath = path.join(this._tempDir, firstFile);\r\n                let buffer = await FileSystemHelper.readFileAsync(filePath);\r\n                // delete the file first to prevent double sending\r\n                await FileSystemHelper.unlinkAsync(filePath);\r\n                let envelopes: Contracts.EnvelopeTelemetry[] = JSON.parse(buffer.toString());\r\n                await this.send(envelopes);\r\n            }\r\n        }\r\n        catch (err) {\r\n            this._onErrorHelper(err);\r\n        }\r\n    }\r\n\r\n    private _onErrorHelper(error: Error): void {\r\n        if (typeof this._onError === \"function\") {\r\n            this._onError(error);\r\n        }\r\n    }\r\n\r\n    private async _fileCleanupTask(): Promise<void> {\r\n        try {\r\n            let files = await FileSystemHelper.readdirAsync(this._tempDir);\r\n            files = files.filter(f => path.basename(f).indexOf(\".ai.json\") > -1);\r\n            if (files.length > 0) {\r\n                for (let i = 0; i < files.length; i++) {\r\n                    // Check expiration\r\n                    let fileCreationDate: Date = new Date(parseInt(files[i].split(\".ai.json\")[0]));\r\n                    let expired = new Date(+(new Date()) - Sender.FILE_RETEMPTION_PERIOD) > fileCreationDate;\r\n                    if (expired) {\r\n                        var filePath = path.join(this._tempDir, files[i]);\r\n                        await FileSystemHelper.unlinkAsync(filePath).catch((err) => {\r\n                            this._onErrorHelper(err);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err.code != \"ENOENT\") {\r\n                this._onErrorHelper(err);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport = Sender;"]}