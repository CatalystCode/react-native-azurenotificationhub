{"version":3,"file":"SamplingTelemetryProcessor.js","sourceRoot":"","sources":["../../TelemetryProcessors/SamplingTelemetryProcessor.ts"],"names":[],"mappings":";;;AAAA,qDAAwD;AAGxD;;GAEG;AACH,SAAgB,0BAA0B,CAAC,QAAqC,EAAE,cAA0D;IACxI,IAAI,kBAAkB,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,mCAAmC;IACjF,IAAI,WAAW,GAAG,KAAK,CAAC;IAExB,IAAI,kBAAkB,KAAK,IAAI,IAAI,kBAAkB,KAAK,SAAS,IAAI,kBAAkB,IAAI,GAAG,EAAE;QAC9F,OAAO,IAAI,CAAC;KACf;SAAM,IAAI,QAAQ,CAAC,IAAI,IAAI,SAAS,CAAC,aAAa,CAAC,MAAM,KAAK,SAAS,CAAC,uBAAuB,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAyC,CAAC,EAAE;QACvJ,6CAA6C;QAC7C,OAAO,IAAI,CAAC;KACf;SAAM,IAAI,cAAc,CAAC,kBAAkB,IAAI,cAAc,CAAC,kBAAkB,CAAC,SAAS,EAAE;QACzF,mGAAmG;QACnG,WAAW,GAAG,mBAAmB,CAAC,cAAc,CAAC,kBAAkB,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,kBAAkB,CAAC;KAC1G;SAAM;QACH,oGAAoG;QACpG,WAAW,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,GAAG,kBAAkB,CAAC;KAC5D;IAED,OAAO,WAAW,CAAC;AACvB,CAAC;AAlBD,gEAkBC;AAED,8BAA8B;AAC9B,SAAgB,mBAAmB,CAAC,KAAa;IAC7C,IAAI,SAAS,GAAG,CAAC,UAAU,CAAC;IAC5B,IAAI,SAAS,GAAG,UAAU,CAAC;IAC3B,IAAI,IAAI,GAAG,IAAI,CAAC;IAEhB,IAAI,CAAC,KAAK,EAAE;QACR,OAAO,CAAC,CAAC;KACZ;IAED,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;QACrB,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;KACzB;IAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACnC,uGAAuG;QACvG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;KACjE;IAED,IAAI,GAAG,IAAI,IAAI,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACtD,OAAO,CAAC,IAAI,GAAG,SAAS,CAAC,GAAG,GAAG,CAAC;AACpC,CAAC;AApBD,kDAoBC","sourcesContent":["import Contracts = require(\"../Declarations/Contracts\");\r\nimport { CorrelationContext } from \"../AutoCollection/CorrelationContextManager\";\r\n\r\n/**\r\n *  A telemetry processor that handles sampling.\r\n */\r\nexport function samplingTelemetryProcessor(envelope: Contracts.EnvelopeTelemetry, contextObjects: { correlationContext: CorrelationContext }): boolean {\r\n    var samplingPercentage = envelope.sampleRate; // Set for us in Client.getEnvelope\r\n    var isSampledIn = false;\r\n\r\n    if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {\r\n        return true;\r\n    } else if (envelope.data && Contracts.TelemetryType.Metric === Contracts.baseTypeToTelemetryType(envelope.data.baseType as Contracts.TelemetryTypeValues)) {\r\n        // Exclude MetricData telemetry from sampling\r\n        return true;\r\n    } else if (contextObjects.correlationContext && contextObjects.correlationContext.operation) {\r\n        // If we're using dependency correlation, sampling should retain all telemetry from a given request\r\n        isSampledIn = getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage;\r\n    } else {\r\n        // If we're not using dependency correlation, sampling should use a random distribution on each item\r\n        isSampledIn = (Math.random() * 100) < samplingPercentage;\r\n    }\r\n\r\n    return isSampledIn;\r\n}\r\n\r\n/** Ported from AI .NET SDK */\r\nexport function getSamplingHashCode(input: string): number {\r\n    var csharpMin = -2147483648;\r\n    var csharpMax = 2147483647;\r\n    var hash = 5381;\r\n\r\n    if (!input) {\r\n        return 0;\r\n    }\r\n\r\n    while (input.length < 8) {\r\n        input = input + input;\r\n    }\r\n\r\n    for (var i = 0; i < input.length; i++) {\r\n        // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)\r\n        hash = ((((hash << 5) + hash) | 0) + input.charCodeAt(i) | 0);\r\n    }\r\n\r\n    hash = hash <= csharpMin ? csharpMax : Math.abs(hash);\r\n    return (hash / csharpMax) * 100;\r\n}"]}