{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/generator-common/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n * @format\n */\n\nimport fs from '@react-native-windows/fs';\nimport chalk from 'chalk';\nimport prompts from 'prompts';\nimport path from 'path';\nimport mustache from 'mustache';\nimport {CodedError} from '@react-native-windows/telemetry';\n\n/**\n * Text to replace, + config options\n */\nexport type Replacements = {\n  useMustache?: boolean;\n  regExpPatternsToRemove?: RegExp[];\n  [key: string]: any;\n};\n\nfunction walk(current: string): string[] {\n  if (!fs.lstatSync(current).isDirectory()) {\n    return [current];\n  }\n\n  const files = fs\n    .readdirSync(current)\n    .map(child => walk(path.join(current, child)));\n  const result: string[] = [];\n  return result.concat.apply([current], files);\n}\n\n/**\n * Get a source file and replace parts of its contents.\n * @param srcPath Path to the source file.\n * @param replacements e.g. {'TextToBeReplaced': 'Replacement'}\n * @return The contents of the file with the replacements applied.\n */\nexport function resolveContents(\n  srcPath: string,\n  replacements: Replacements,\n): string {\n  let content = fs.readFileSync(srcPath, 'utf8');\n\n  if (content.includes('\\r\\n')) {\n    // CRLF file, make sure multiline replacements are also CRLF\n    for (const key of Object.keys(replacements)) {\n      if (typeof replacements[key] === 'string') {\n        replacements[key] = replacements[key].replace(/(?<!\\r)\\n/g, '\\r\\n');\n      }\n    }\n  } else {\n    // LF file, make sure multiline replacements are also LF\n    for (const key of Object.keys(replacements)) {\n      if (typeof replacements[key] === 'string') {\n        replacements[key] = replacements[key].replace(/\\r\\n/g, '\\n');\n      }\n    }\n  }\n\n  if (replacements.useMustache) {\n    content = mustache.render(content, replacements);\n    (replacements.regExpPatternsToRemove || []).forEach(regexPattern => {\n      content = content.replace(new RegExp(regexPattern, 'g'), '');\n    });\n  } else {\n    Object.keys(replacements).forEach(regex => {\n      content = content.replace(new RegExp(regex, 'g'), replacements[regex]);\n    });\n  }\n  return content;\n}\n\n// Binary files, don't process these (avoid decoding as utf8)\nconst binaryExtensions = ['.png', '.jar', '.keystore'];\n\ntype ContentChangedCallbackOption = 'identical' | 'changed' | 'new' | null;\n\ntype ContentChangedCallback = (\n  path: string,\n  option: ContentChangedCallbackOption,\n) => Promise<'keep' | 'overwrite'>;\n\n/**\n * Copy a file to given destination, replacing parts of its contents.\n * @param srcPath Path to a file to be copied.\n * @param destPath Destination path.\n * @param replacements: e.g. {'TextToBeReplaced': 'Replacement'}\n * @param contentChangedCallback\n *        Used when upgrading projects. Based on if file contents would change\n *        when being replaced, allows the caller to specify whether the file\n *        should be replaced or not.\n *        If null, files will be overwritten.\n *        Function(path, 'identical' | 'changed' | 'new') => 'keep' | 'overwrite'\n */\nexport async function copyAndReplace(\n  srcPath: string,\n  destPath: string,\n  replacements: Replacements,\n  contentChangedCallback: ContentChangedCallback | null,\n) {\n  if (fs.lstatSync(srcPath).isDirectory()) {\n    if (!fs.existsSync(destPath)) {\n      fs.mkdirSync(destPath);\n    }\n    // Not recursive\n    return;\n  }\n\n  const extension = path.extname(srcPath);\n  if (binaryExtensions.includes(extension)) {\n    // Binary file\n    let shouldOverwrite = 'overwrite';\n    if (contentChangedCallback) {\n      const newContentBuffer = fs.readFileSync(srcPath);\n      let contentChanged: ContentChangedCallbackOption = 'identical';\n      try {\n        const origContentBuffer = fs.readFileSync(destPath);\n        if (Buffer.compare(origContentBuffer, newContentBuffer) !== 0) {\n          contentChanged = 'changed';\n        }\n      } catch (err) {\n        if ((err as NodeJS.ErrnoException).code === 'ENOENT') {\n          contentChanged = 'new';\n        } else {\n          throw err;\n        }\n      }\n      shouldOverwrite = await contentChangedCallback(destPath, contentChanged);\n    }\n    if (shouldOverwrite === 'overwrite') {\n      copyBinaryFile(srcPath, destPath, err => {\n        if (err) {\n          throw err;\n        }\n      });\n    }\n  } else {\n    // Text file\n    const srcPermissions = fs.statSync(srcPath).mode;\n    const content = resolveContents(srcPath, replacements);\n\n    let shouldOverwrite = 'overwrite';\n    if (contentChangedCallback) {\n      // Check if contents changed and ask to overwrite\n      let contentChanged: ContentChangedCallbackOption = 'identical';\n      try {\n        const origContent = fs.readFileSync(destPath, 'utf8');\n        if (content !== origContent) {\n          // logger.info('Content changed: ' + destPath);\n          contentChanged = 'changed';\n        }\n      } catch (err) {\n        if ((err as NodeJS.ErrnoException).code === 'ENOENT') {\n          contentChanged = 'new';\n        } else {\n          throw err;\n        }\n      }\n      shouldOverwrite = await contentChangedCallback(destPath, contentChanged);\n    }\n    if (shouldOverwrite === 'overwrite') {\n      fs.writeFileSync(destPath, content, {\n        encoding: 'utf8',\n        mode: srcPermissions,\n      });\n    }\n  }\n}\n\n/**\n * Same as 'cp' on Unix. Don't do any replacements.\n */\nfunction copyBinaryFile(\n  srcPath: string,\n  destPath: string,\n  cb: (err?: Error) => void,\n) {\n  let cbCalled = false;\n  const srcPermissions = fs.statSync(srcPath).mode;\n  const readStream = fs.createReadStream(srcPath);\n  readStream.on('error', err => {\n    done(err);\n  });\n  const writeStream = fs.createWriteStream(destPath, {\n    mode: srcPermissions,\n  });\n  writeStream.on('error', err => {\n    done(err);\n  });\n  writeStream.on('close', () => {\n    done();\n  });\n  readStream.pipe(writeStream);\n  function done(err?: Error) {\n    if (!cbCalled) {\n      cb(err);\n      cbCalled = true;\n    }\n  }\n}\n\nexport function createDir(destPath: string) {\n  if (!fs.existsSync(destPath)) {\n    fs.mkdirSync(destPath);\n  }\n}\n\nexport async function copyAndReplaceWithChangedCallback(\n  srcPath: string,\n  destRoot: string,\n  relativeDestPath: string,\n  replacements?: Record<string, string>,\n  alwaysOverwrite?: boolean,\n) {\n  if (!replacements) {\n    replacements = {};\n  }\n  const contentChangedCallback: ContentChangedCallback = alwaysOverwrite\n    ? (_, contentChanged) =>\n        alwaysOverwriteContentChangedCallback(\n          srcPath,\n          relativeDestPath,\n          contentChanged,\n        )\n    : (_, contentChanged) =>\n        upgradeFileContentChangedCallback(\n          srcPath,\n          relativeDestPath,\n          contentChanged,\n        );\n\n  await copyAndReplace(\n    srcPath,\n    path.join(destRoot, relativeDestPath),\n    replacements,\n    contentChangedCallback,\n  );\n}\n\nexport async function copyAndReplaceAll(\n  srcPath: string,\n  destPath: string,\n  relativeDestDir: string,\n  replacements: Replacements,\n  alwaysOverwrite: boolean,\n) {\n  for (const absoluteSrcFilePath of walk(srcPath)) {\n    const filename = path.relative(srcPath, absoluteSrcFilePath);\n    const relativeDestPath = path.join(relativeDestDir, filename);\n    await copyAndReplaceWithChangedCallback(\n      absoluteSrcFilePath,\n      destPath,\n      relativeDestPath,\n      replacements,\n      alwaysOverwrite,\n    );\n  }\n}\n\nasync function alwaysOverwriteContentChangedCallback(\n  absoluteSrcFilePath: string,\n  relativeDestPath: string,\n  contentChanged: ContentChangedCallbackOption,\n): Promise<'keep' | 'overwrite'> {\n  if (contentChanged === 'new') {\n    console.log(`${chalk.bold('new')} ${relativeDestPath}`);\n    return 'overwrite';\n  }\n  if (contentChanged === 'changed') {\n    console.log(\n      `${chalk.bold('changed')} ${relativeDestPath} ${chalk.yellow(\n        '[overwriting]',\n      )}`,\n    );\n    return 'overwrite';\n  }\n  if (contentChanged === 'identical') {\n    return 'keep';\n  }\n  throw new CodedError(\n    'Autolinking',\n    `Unknown file changed state: ${relativeDestPath}, ${contentChanged}`,\n  );\n}\n\nasync function upgradeFileContentChangedCallback(\n  absoluteSrcFilePath: string,\n  relativeDestPath: string,\n  contentChanged: ContentChangedCallbackOption,\n): Promise<'keep' | 'overwrite'> {\n  if (contentChanged === 'new') {\n    console.log(`${chalk.bold('new')} ${relativeDestPath}`);\n    return 'overwrite';\n  }\n  if (contentChanged === 'changed') {\n    console.log(\n      `${chalk.bold(relativeDestPath)} ` +\n        `has changed in the new version.\\nDo you want to keep your ${relativeDestPath} or replace it with the ` +\n        'latest version?\\nMake sure you have any changes you made to this file saved somewhere.\\n' +\n        `You can see the new version here: ${absoluteSrcFilePath}`,\n    );\n\n    const {shouldReplace} = await prompts([\n      {\n        name: 'shouldReplace',\n        type: 'confirm',\n        message: `Do you want to replace ${relativeDestPath}?`,\n        initial: false,\n      },\n    ]);\n\n    return shouldReplace ? 'overwrite' : 'keep';\n  }\n  if (contentChanged === 'identical') {\n    return 'keep';\n  }\n  throw new CodedError(\n    'Autolinking',\n    `Unknown file changed state: ${relativeDestPath}, ${contentChanged}`,\n  );\n}\n"]}